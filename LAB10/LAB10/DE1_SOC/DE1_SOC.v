
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// HPS //////////
	inout 		          		HPS_CONV_USB_N,
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,
	output		          		HPS_ENET_GTX_CLK,
	inout 		          		HPS_ENET_INT_N,
	output		          		HPS_ENET_MDC,
	inout 		          		HPS_ENET_MDIO,
	input 		          		HPS_ENET_RX_CLK,
	input 		     [3:0]		HPS_ENET_RX_DATA,
	input 		          		HPS_ENET_RX_DV,
	output		     [3:0]		HPS_ENET_TX_DATA,
	output		          		HPS_ENET_TX_EN,
	inout 		     [3:0]		HPS_FLASH_DATA,
	output		          		HPS_FLASH_DCLK,
	output		          		HPS_FLASH_NCSO,
	inout 		     [1:0]		HPS_GPIO,
	inout 		          		HPS_GSENSOR_INT,
	inout 		          		HPS_I2C1_SCLK,
	inout 		          		HPS_I2C1_SDAT,
	inout 		          		HPS_I2C2_SCLK,
	inout 		          		HPS_I2C2_SDAT,
	inout 		          		HPS_I2C_CONTROL,
	inout 		          		HPS_KEY,
	inout 		          		HPS_LED,
	output		          		HPS_SD_CLK,
	inout 		          		HPS_SD_CMD,
	inout 		     [3:0]		HPS_SD_DATA,
	output		          		HPS_SPIM_CLK,
	input 		          		HPS_SPIM_MISO,
	output		          		HPS_SPIM_MOSI,
	inout 		          		HPS_SPIM_SS,
	input 		          		HPS_UART_RX,
	output		          		HPS_UART_TX,
	input 		          		HPS_USB_CLKOUT,
	inout 		     [7:0]		HPS_USB_DATA,
	input 		          		HPS_USB_DIR,
	input 		          		HPS_USB_NXT,
	output		          		HPS_USB_STP
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	
   assign HEX5 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	assign HEX4 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	assign HEX3 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	assign HEX2 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	assign HEX1 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	assign HEX0 = 7'b1111111;	//something wrong, so it has to be forced to set 1111111 to light off
	
	wire CLOCK_100, CLOCK_25;
	wire [15:0] ddr3_avl_addr_0;
	reg ddr3_avl_read_req_0;
	wire [23:0] ddr3_avl_rdata_0;
	reg ddr3_avl_write_req_0;
	wire [23:0] ddr3_avl_wdata_0;
	wire ddr3_avl_rdata_valid_0, ddr3_avl_ready_0;
	wire [3:0] ddr3_avl_size_0;
	
	assign ddr3_avl_addr_0 = 16'd0;
	assign ddr3_avl_wdata_0 = SW[7:0];
	assign ddr3_avl_rdata_valid_0 = 1;
	assign ddr3_avl_ready_0 = 0;
	assign ddr3_avl_size_0 = 4'd1;
	
	soc_system u0 (
				
			  .clock_bridge_0_in_clk_clk             (CLOCK_100),                            //                  clock_bridge_0_in_clk.clk
			  
			  .memory_mem_a                          ( HPS_DDR3_ADDR),                          //          memory.mem_a
			  .memory_mem_ba                         ( HPS_DDR3_BA),                         //                .mem_ba
			  .memory_mem_ck                         ( HPS_DDR3_CK_P),                         //                .mem_ck
			  .memory_mem_ck_n                       ( HPS_DDR3_CK_N),                       //                .mem_ck_n
			  .memory_mem_cke                        ( HPS_DDR3_CKE),                        //                .mem_cke
			  .memory_mem_cs_n                       ( HPS_DDR3_CS_N),                       //                .mem_cs_n
			  .memory_mem_ras_n                      ( HPS_DDR3_RAS_N),                      //                .mem_ras_n
			  .memory_mem_cas_n                      ( HPS_DDR3_CAS_N),                      //                .mem_cas_n
			  .memory_mem_we_n                       ( HPS_DDR3_WE_N),                       //                .mem_we_n
			  .memory_mem_reset_n                    ( HPS_DDR3_RESET_N),                    //                .mem_reset_n
			  .memory_mem_dq                         ( HPS_DDR3_DQ),                         //                .mem_dq
			  .memory_mem_dqs                        ( HPS_DDR3_DQS_P),                        //                .mem_dqs
			  .memory_mem_dqs_n                      ( HPS_DDR3_DQS_N),                      //                .mem_dqs_n
			  .memory_mem_odt                        ( HPS_DDR3_ODT),                        //                .mem_odt
			  .memory_mem_dm                         ( HPS_DDR3_DM),                         //                .mem_dm
			  .memory_oct_rzqin                      ( HPS_DDR3_RZQ),                      //                .oct_rzqin
					

			  .address_span_extender_0_windowed_slave_address       (ddr3_avl_addr_0),       // address_span_extender_0_windowed_slave.address
			  .address_span_extender_0_windowed_slave_read          (ddr3_avl_read_req_0),          //  .read
			  .address_span_extender_0_windowed_slave_readdata      (ddr3_avl_rdata_0),      // .readdata
			  .address_span_extender_0_windowed_slave_write         (ddr3_avl_write_req_0),         //  .write
			  .address_span_extender_0_windowed_slave_writedata     (ddr3_avl_wdata_0),     //  .writedata
			  .address_span_extender_0_windowed_slave_readdatavalid (ddr3_avl_rdata_valid_0), //  .readdatavalid
			  .address_span_extender_0_windowed_slave_waitrequest   (ddr3_avl_ready_0),   //  .waitrequest
			  .address_span_extender_0_windowed_slave_byteenable    (32'hFFFFFFFF),    //  .byteenable
			  .address_span_extender_0_windowed_slave_burstcount    (ddr3_avl_size_0),    //  .burstcount
		 );
	



//=======================================================
//  Structural coding
//=======================================================
	
	//double frequency
	double_frequency df(CLOCK_50, CLOCK_100);
	//half frequency
	half_frequency hf(CLOCK_50, CLOCK_25);
	
	/******** Part3 ********/
	
	wire [23:0] pixel_q;
	reg [23:0] pixel_q_reg;
	reg data_enable;
	reg [9:0] data_enable_count, column_count;
	assign VGA_CLK = CLOCK_25;
	assign VGA_BLANK_N = 1'b1;
	assign VGA_SYNC_N  = 1'b0;
	assign VGA_B = pixel_q_reg[23:16];
	assign VGA_G = pixel_q_reg[15:8];
	assign VGA_R = pixel_q_reg[7:0];
	
	input_badge u_input_badge(
		.iStart_n(1'b0),
		.iCLK(CLOCK_25),
		.iRST_N(1'b1),
		
		.oData_Enable(data_enable),
		.oData(pixel_q),
		.HSYNC(VGA_HS),				//connect this  pin  to VGA_HS
		.VSYNC(VGA_VS),				//connect this  pin  to VGA_VS
	);
	
	always @(posedge CLOCK_25) begin
		if(data_enable_count >= 197 && data_enable_count <= 207 && column_count >= 204 && column_count <= 249 && SW[0] == 1) begin
			pixel_q_reg = 24'hFFFFFF;
		end
		else begin
			pixel_q_reg = pixel_q;
		end
	end
	
	always @(posedge data_enable) begin
		if(data_enable_count >= 479) begin
			data_enable_count = 0;
		end
		else begin
			data_enable_count = data_enable_count + 1;
		end
	end
	
	always @(posedge CLOCK_25) begin
		if(data_enable == 1) begin
			if(column_count >= 639) begin
				column_count = 0;
			end
			else begin
				column_count = column_count + 1;
			end
		end
		else begin
			column_count = 0;
		end
	end
	
	
	/******** Part4 ********/
	
	//VGA
	/*
	wire read_request;
	
	VGA_640_480 VGA(
		.iStart_n(1'b0),
		.iCLK(CLOCK_25),
		.iRST_N(1'b1),
		
		.iData_R(ddr3_avl_rdata_0[23:16]),			//connect these pins to the q[](depends on how you store the pixel in SDRAM) of FIFO for SDRAM_read
		.iData_G(ddr3_avl_rdata_0[15:8]),			//connect these pins to the q[](depends on how you store the pixel in SDRAM) of FIFO for SDRAM_read
		.iData_B(ddr3_avl_rdata_0[7:0]),			//connect these pins to the q[](depends on how you store the pixel in SDRAM) of FIFO for SDRAM_read
		
		.oPixel_read_request(read_request),//connect this  pin  to the rdreq of FIFO for SDRAM_read
		.oData_R(VGA_R[7:0]),			//connect these pins to VGA_R[7:0]
		.oData_G(VGA_G[7:0]),			//connect these pins to VGA_G[7:0]
		.oData_B(VGA_B[7:0]),			//connect these pins to VGA_B[7:0]
		.HSYNC(VGA_HS),				//connect this  pin  to VGA_HS
		.VSYNC(VGA_VS),				//connect this  pin  to VGA_VS
		.VGA_BLANK_N(VGA_BLANK_N),		//connect this  pin  to VGA_BLANK_N
		.VGA_SYNC_N(VGA_SYNC_N)			//connect this  pin  to VGA_SYNC_N
	);
	
	wire [23:0] pixel_q;
	reg data_enable;
	wire hsync, vsync;
	
	input_badge u_input_badge(
		.iStart_n(1'b0),
		.iCLK(CLOCK_25),
		.iRST_N(1'b1),
		
		.oData_Enable(data_enable),
		.oData(pixel_q),
		.HSYNC(hsync),
		.VSYNC(vsync),
	);
	
	reg [25:0] cnt = 0;
	
	always @(posedge CLOCK_100) begin
		//write mode
		if(cnt <= 10000) begin
			ddr3_avl_read_req_0 = 0;
			cnt = cnt + 1;
			if(SW[9]) begin
				ddr3_avl_write_req_0 = 1;
			end
			else begin
				ddr3_avl_write_req_0 = 0;
			end
		end
		//read mode
		else if(cnt <= 20000) begin
			ddr3_avl_read_req_0 = 1;
			ddr3_avl_write_req_0 = 0;
			cnt = cnt + 1;
		end
		else begin
			ddr3_avl_read_req_0 = 0;
			ddr3_avl_write_req_0 = 0;
			cnt = 0;
		end
	end
*/
endmodule

//bch to seg
module seg_decoder (bch, seg);
	input [3:0] bch;
	output reg [6:0] seg;
	
	always @(bch) begin
		case (bch)
			0 : seg = 7'b1000000;
			1 : seg = 7'b1111001;
			2 : seg = 7'b0100100;
			3 : seg = 7'b0110000;
			4 : seg = 7'b0011001;
			5 : seg = 7'b0010010;
			6 : seg = 7'b0000010;
			7 : seg = 7'b1111000;
			8 : seg = 7'b0000000;
			9 : seg = 7'b0010000;
			10 : seg = 7'b0001000;	//A
			11 : seg = 7'b0000011;	//b
			12 : seg = 7'b1000110;	//C
			13 : seg = 7'b0100001;	//d
			14 : seg = 7'b0000110;	//E
			15 : seg = 7'b0001110;	//F
			//lights out
			default : seg = 7'b1111111;
		endcase
	end
endmodule

//display two digit in seg
module two_digit_seg (num, seg1, seg0);
	input [7:0] num;
	output [6:0] seg1, seg0;
	
	seg_decoder de1(num[7:4], seg1);
	seg_decoder de0(num[3:0], seg0);
endmodule

module double_frequency (in_clk, out_clk);
	input in_clk;
	output out_clk;
	reg temp;
	
	assign out_clk = ~(in_clk^~temp);
	
	always @(posedge in_clk) begin
		temp <= ~temp;
	end
endmodule

module half_frequency (in_clk, out_clk);
	input in_clk;
	output reg out_clk;
	
	always @(posedge in_clk) begin
		out_clk = ~out_clk;
	end
endmodule

